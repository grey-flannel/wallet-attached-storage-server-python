# Amazon S3 Backend

Persists spaces and resources to an Amazon S3 bucket. Resource content types are stored as S3's native `ContentType` metadata -- no sidecar files needed for resources.

## When to Use

- Production deployments on AWS
- Large file storage (S3 handles objects up to 5 TB)
- Multi-server setups that need shared storage without a database

## Installation

```bash
pip install "wallet-attached-storage-server[s3]"
```

This installs `boto3`.

## Configuration

```bash
export WAS_STORAGE_BACKEND=s3
export WAS_STORAGE_BUCKET=my-was-bucket
export WAS_STORAGE_PREFIX=prod/        # optional, default: "" (bucket root)
```

## Environment Variables

| Variable              | Required | Default | Description                                  |
|-----------------------|----------|---------|----------------------------------------------|
| `WAS_STORAGE_BACKEND` | Yes      | --      | Set to `s3`                                  |
| `WAS_STORAGE_BUCKET`  | Yes      | --      | S3 bucket name                               |
| `WAS_STORAGE_PREFIX`  | No       | `""`    | Key prefix (include trailing `/` if desired) |

## AWS Credentials

Authentication uses the standard [boto3 credential chain](https://boto3.amazonaws.com/v1/documentation/api/latest/guide/credentials.html):

1. Environment variables (`AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`)
2. Shared credentials file (`~/.aws/credentials`)
3. IAM role (EC2 instance profile, ECS task role, Lambda execution role)
4. SSO / credential process

No WAS-specific credential variables -- configure AWS credentials as you normally would.

## S3 Object Layout

```text
{prefix}spaces/{space_uuid}/_meta.json              # {"id": "...", "controller": "..."}
{prefix}spaces/{space_uuid}/resources/%2Ffile.txt    # resource content (ContentType set on object)
```

Resource paths are percent-encoded. Content type is stored as S3's native `ContentType` on the object, not in a sidecar file.

## Running

```bash
# Create the bucket (if needed)
aws s3 mb s3://my-was-bucket

export WAS_STORAGE_BACKEND=s3
export WAS_STORAGE_BUCKET=my-was-bucket

uvicorn was_server:app --port 8080
```

## IAM Policy

Minimum permissions needed:

```json
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "s3:GetObject",
                "s3:PutObject",
                "s3:DeleteObject",
                "s3:ListBucket",
                "s3:HeadObject"
            ],
            "Resource": [
                "arn:aws:s3:::my-was-bucket",
                "arn:aws:s3:::my-was-bucket/*"
            ]
        }
    ]
}
```

## Implementation Notes

- **No sidecar for resources**: Content type is stored as S3's native `ContentType` on the object, retrieved automatically on `GetObject`
- **Paginated deletes**: `delete_space` lists all objects under the space prefix and deletes them in batches (S3's `DeleteObjects` handles up to 1000 keys per call)
- **Existence checks**: `put_resource` and `delete_resource` use `HeadObject` to verify the space/resource exists before acting
- **Prefix isolation**: Multiple WAS servers can share a bucket by using different prefixes

## Limitations

- `list_spaces` scans all `_meta.json` objects under the prefix -- O(n) with the number of spaces. Fine for moderate scale; consider PostgreSQL if you have thousands of spaces
- S3 is eventually consistent for overwrite PUTs in some edge cases (though strong consistency is now the default for most operations)
